[[_TOC_]]
---
title: promp::ProMP
summary: Class that implements a multi-dimensional Probabilistic Motion Primitive. References: 

---

# promp::ProMP



Class that implements a multi-dimensional Probabilistic Motion Primitive. References:  [More...](#detailed-description)


`#include <promp.hpp>`

## Public Functions

|                | Name           |
| -------------- | -------------- |
| | **[ProMP](#function-promp)**(const std::vector< [Trajectory]() > & data, int num_bf, double std_bf =-1)<br>constructor: The constructor will parameterize a phase vector, and compute the basis function matrix \( \Psi \) for all phase steps. Then, for each demonstration within the std::vector `data`, it will estimate a. vector of basis functions' weights \( w_i \). Lastly, it fits a gaussian over all the weight vectors to obtain \( \mu_w \), and \( \Sigma_w \) |
| | **[ProMP](#function-promp)**(const [TrajectoryGroup]() & data, int num_bf, double std_bf =-1)<br>constructor: The constructor will parameterize a phase vector, and compute the basis function matrix \( \Psi \) for all phase steps. Then, for each demonstration within the std::vector `data`, it will estimate a. vector of basis functions' weights \( w_i \). Lastly, it fits a gaussian over all the weight vectors to obtain \( \mu_w \), and \( \Sigma_w \) |
| | **[ProMP](#function-promp)**(const Eigen::VectorXd & w, const Eigen::MatrixXd & cov_w, double std_bf, int n_sample, size_t dims, double time_mod =1.0)<br>This is an alternate constructor that uses prelearned weights, covariance and number of samples in the trajectory.  |
| const Eigen::MatrixXd & | **[get_basis_function](#function-get-basis-function)**() const<br>Gets the basis function matrix for the current trained [ProMP]().  |
| Eigen::MatrixXd | **[generate_basis_function](#function-generate-basis-function)**(const Eigen::VectorXd & phase) const<br>generates basis functions  |
| Eigen::VectorXd | **[compute_phase](#function-compute-phase)**(size_t timesteps) const<br>maps time vector into a phase vector give a desired number of timesteps  |
| const Eigen::VectorXd & | **[get_phase](#function-get-phase)**() const<br>Gets the phase vector.  |
| const Eigen::VectorXd & | **[get_weights](#function-get-weights)**() const<br>Gets the vector of the mean of all weights \( \mu_w \).  |
| const Eigen::MatrixXd & | **[get_covariance](#function-get-covariance)**() const<br>Gets the co-variance matrix \( \Sigma_w \).  |
| int | **[get_n_samples](#function-get-n-samples)**() const<br>Gets the number of samples for the trajectory \( \s_ \).  |
| int | **[get_traj_length](#function-get-traj-length)**() const<br>Gets the trajectory length.  |
| double | **[get_std_bf](#function-get-std-bf)**() const<br>Gets the std deviation \( \std_bf \) of the [ProMP]().  |
| size_t | **[get_dims](#function-get-dims)**() const<br>return the number of dimensions represented and generated by the promp  |
| double | **[get_mean_demo_time_mod](#function-get-mean-demo-time-mod)**() const<br>Gets the average time modulation in the demonstrations used to train the [ProMP]().  |
| void | **[set_ridge_factor](#function-set-ridge-factor)**(double ridge_factor)<br>Set the ridge factor value which condition the pphi inverse. Helps against singularities.  |
| Eigen::MatrixXd | **[generate_trajectory](#function-generate-trajectory)**() const<br>Generates MEAN trajectory based on current weights distribution and rbf.  |
| Eigen::MatrixXd | **[generate_trajectory](#function-generate-trajectory)**(size_t req_num_steps) const<br>Generates MEAN trajectory based on current weights distribution and a required number of steps.  |
| Eigen::MatrixXd | **[generate_trajectory_with_speed](#function-generate-trajectory-with-speed)**(double req_phase_speed) const<br>Generates MEAN trajectory based on current weights distributions and a required phase speed \( \dot{z}_t \).  |
| Eigen::MatrixXd | **[generate_trajectory_at](#function-generate-trajectory-at)**(const Eigen::VectorXd & phase) const |
| void | **[condition_goal](#function-condition-goal)**(const Eigen::VectorXd & goal, const Eigen::MatrixXd & std)<br>set desired goal/end point for trajectory  |
| void | **[condition_start](#function-condition-start)**(const Eigen::VectorXd & start, const Eigen::MatrixXd & std)<br>set desired start/initial point for trajectory  |
| Eigen::MatrixXd | **[gen_traj_std_dev](#function-gen-traj-std-dev)**(size_t req_num_steps =0) const<br>Generates standard deviation vector with the standard deviation for every time step, with a certain number of time steps.  |
| std::vector< Eigen::MatrixXd > | **[generate_trajectory_covariance](#function-generate-trajectory-covariance)**(size_t req_num_steps =0) const<br>Generates step covariance matrices for for each step of the trajectory, with a certain number of time steps.  |
| void | **[condition_via_points](#function-condition-via-points)**(const std::vector< std::tuple< int, Eigen::VectorXd, Eigen::MatrixXd > > & via_points)<br>Conditions all via points registered in 'viaPoints_'. It updates __mean_w_ and _cov_w and clear _via_points vector.  |
| void | **[condition_via_point](#function-condition-via-point)**(int t, const Eigen::VectorXd & via_point, const Eigen::MatrixXd & std)<br>Conditions all via points registered in 'viaPoints_'. It updates __mean_w_ and _cov_w and clear _via_points vector.  |
| Eigen::VectorXd | **[get_upper_weights](#function-get-upper-weights)**(double K) |
| Eigen::VectorXd | **[get_lower_weights](#function-get-lower-weights)**(double K) |
| double | **[phase_speed_from_steps](#function-phase-speed-from-steps)**(int steps)<br>generate the speed from a number of steps  |

## Friends

|                | Name           |
| -------------- | -------------- |
| std::ostream & | **[operator<<](#friend-operator<<)**(std::ostream & out, const [ProMP]() & mp) <br>Overloads << operator in order to print the weights of a given promp.  |

## Detailed Description

```cpp
class promp::ProMP;
```

Class that implements a multi-dimensional Probabilistic Motion Primitive. References: 



* Paraschos A, Daniel C, Peters J, Neumann G. Probabilistic movement primitives. Advances in neural information processing systems. 2013. [[pdf]](https://www.ias.informatik.tu-darmstadt.de/uploads/Publications/Paraschos_NIPS_2013.pdf)
* Paraschos A, Daniel C, Peters J, Neumann G. Using probabilistic movement primitives in robotics. Autonomous Robots. 2018 Mar;42(3):529-51. [[pdf]](https://www.ias.informatik.tu-darmstadt.de/uploads/Team/AlexandrosParaschos/promps_auro.pdf). 

## Public Functions Documentation

### function ProMP

```cpp
inline ProMP(
    const std::vector< Trajectory > & data,
    int num_bf,
    double std_bf =-1
)
```

constructor: The constructor will parameterize a phase vector, and compute the basis function matrix \( \Psi \) for all phase steps. Then, for each demonstration within the std::vector `data`, it will estimate a. vector of basis functions' weights \( w_i \). Lastly, it fits a gaussian over all the weight vectors to obtain \( \mu_w \), and \( \Sigma_w \)

**Parameters**: 

  * **data** vector of trajectories. All the trajectories MUST have the same length and same dimension. 
  * **num_bf** number of basis functions 
  * **std_bf** standard deviation; this is set automatically to 1.0 / (n_rbf*n_rbf) if std_bf <= 0 


### function ProMP

```cpp
inline ProMP(
    const TrajectoryGroup & data,
    int num_bf,
    double std_bf =-1
)
```

constructor: The constructor will parameterize a phase vector, and compute the basis function matrix \( \Psi \) for all phase steps. Then, for each demonstration within the std::vector `data`, it will estimate a. vector of basis functions' weights \( w_i \). Lastly, it fits a gaussian over all the weight vectors to obtain \( \mu_w \), and \( \Sigma_w \)

**Parameters**: 

  * **data** vector of trajectories. All the trajectories MUST have the same length and same dimension. 
  * **num_bf** number of basis functions 
  * **std_bf** standard deviation; this is set automatically to 1.0 / (n_rbf*n_rbf) if std_bf <= 0 


### function ProMP

```cpp
ProMP(
    const Eigen::VectorXd & w,
    const Eigen::MatrixXd & cov_w,
    double std_bf,
    int n_sample,
    size_t dims,
    double time_mod =1.0
)
```

This is an alternate constructor that uses prelearned weights, covariance and number of samples in the trajectory. 

**Parameters**: 

  * **w** The mean of weights' distribution 
  * **cov_w** The co-variance of weights' distribution 
  * **std_bf** The standard deviation of each basis function 
  * **n_sample** The number of samples required for the trajectory 


### function get_basis_function

```cpp
const Eigen::MatrixXd & get_basis_function() const
```

Gets the basis function matrix for the current trained [ProMP](). 

**Return**: The basis function \( \Psi \). 

### function generate_basis_function

```cpp
Eigen::MatrixXd generate_basis_function(
    const Eigen::VectorXd & phase
) const
```

generates basis functions 

**Parameters**: 

  * **phase** 


**Return**: matrix of basis functions 

### function compute_phase

```cpp
Eigen::VectorXd compute_phase(
    size_t timesteps
) const
```

maps time vector into a phase vector give a desired number of timesteps 

### function get_phase

```cpp
const Eigen::VectorXd & get_phase() const
```

Gets the phase vector. 

**Return**: The phase vector. 

### function get_weights

```cpp
const Eigen::VectorXd & get_weights() const
```

Gets the vector of the mean of all weights \( \mu_w \). 

**Return**: The weights. 

### function get_covariance

```cpp
const Eigen::MatrixXd & get_covariance() const
```

Gets the co-variance matrix \( \Sigma_w \). 

**Return**: The co-variance matrix. 

### function get_n_samples

```cpp
int get_n_samples() const
```

Gets the number of samples for the trajectory \( \s_ \). 

**Return**: The number of samples for the trajectory 

### function get_traj_length

```cpp
int get_traj_length() const
```

Gets the trajectory length. 

**Return**: The trajectory length 

### function get_std_bf

```cpp
double get_std_bf() const
```

Gets the std deviation \( \std_bf \) of the [ProMP](). 

**Return**: The std deviation. 

### function get_dims

```cpp
size_t get_dims() const
```

return the number of dimensions represented and generated by the promp 

**Return**: Number of dimensions of the generated function 

### function get_mean_demo_time_mod

```cpp
double get_mean_demo_time_mod() const
```

Gets the average time modulation in the demonstrations used to train the [ProMP](). 

**Return**: m_alpha_ The avergae demo time modulation 

### function set_ridge_factor

```cpp
void set_ridge_factor(
    double ridge_factor
)
```

Set the ridge factor value which condition the pphi inverse. Helps against singularities. 

**Parameters**: 

  * **ridge_factor** 


### function generate_trajectory

```cpp
Eigen::MatrixXd generate_trajectory() const
```

Generates MEAN trajectory based on current weights distribution and rbf. 

**Return**: Mean trajectory 

### function generate_trajectory

```cpp
Eigen::MatrixXd generate_trajectory(
    size_t req_num_steps
) const
```

Generates MEAN trajectory based on current weights distribution and a required number of steps. 

**Parameters**: 

  * **req_num_steps** The requested number of steps for trajectory


**Return**: Mean trajectory 

### function generate_trajectory_with_speed

```cpp
Eigen::MatrixXd generate_trajectory_with_speed(
    double req_phase_speed
) const
```

Generates MEAN trajectory based on current weights distributions and a required phase speed \( \dot{z}_t \). 

**Parameters**: 

  * **req_phase_speed** The request phase speed. ** To play trajectory at orignal speed set \( \dot{z}_t = 1.0 \)**.


**Return**: { description_of_the_return_value } 

### function generate_trajectory_at

```cpp
Eigen::MatrixXd generate_trajectory_at(
    const Eigen::VectorXd & phase
) const
```


### function condition_goal

```cpp
void condition_goal(
    const Eigen::VectorXd & goal,
    const Eigen::MatrixXd & std
)
```

set desired goal/end point for trajectory 

**Parameters**: 

  * **goal** desired value at end 
  * **std** desired standard deviation. ** typically around \( 10^{-6}\) for accuracy **


**Return**: 

### function condition_start

```cpp
void condition_start(
    const Eigen::VectorXd & start,
    const Eigen::MatrixXd & std
)
```

set desired start/initial point for trajectory 

**Parameters**: 

  * **start** desired value at start 
  * **std** desired standard deviation.** typically around \( 10^{-6}\) for accuracy **


**Return**: 

### function gen_traj_std_dev

```cpp
Eigen::MatrixXd gen_traj_std_dev(
    size_t req_num_steps =0
) const
```

Generates standard deviation vector with the standard deviation for every time step, with a certain number of time steps. 

**Parameters**: 

  * **req_num_steps** The requested number steps. if <= 0 (default) use the internal phase parametrization


**Return**: Standard Deviation Vector \( DIAG( \Sigma ) \)

### function generate_trajectory_covariance

```cpp
std::vector< Eigen::MatrixXd > generate_trajectory_covariance(
    size_t req_num_steps =0
) const
```

Generates step covariance matrices for for each step of the trajectory, with a certain number of time steps. 

**Parameters**: 

  * **req_num_steps** The requested number steps. if <= 0 (default) use the internal phase parametrization


**Return**: std::vector containg and entry for each step covariance matrix 

equivalent to (a little slower)


### function condition_via_points

```cpp
void condition_via_points(
    const std::vector< std::tuple< int, Eigen::VectorXd, Eigen::MatrixXd > > & via_points
)
```

Conditions all via points registered in 'viaPoints_'. It updates __mean_w_ and _cov_w and clear _via_points vector. 

### function condition_via_point

```cpp
void condition_via_point(
    int t,
    const Eigen::VectorXd & via_point,
    const Eigen::MatrixXd & std
)
```

Conditions all via points registered in 'viaPoints_'. It updates __mean_w_ and _cov_w and clear _via_points vector. 

**Parameters**: 

  * **t** time at which via point is to be added (between 0 and LAST TIME STEP) 
  * **via_point** desired value at via point 
  * **std** desired standard deviation.** typically around \( 10^{-6}\) for accuracy **


**Return**: 

**Todo**: Use phase \( z_t\) instead of time step t. 

set via point for trajectory 


### function get_upper_weights

```cpp
Eigen::VectorXd get_upper_weights(
    double K
)
```


### function get_lower_weights

```cpp
Eigen::VectorXd get_lower_weights(
    double K
)
```


### function phase_speed_from_steps

```cpp
inline double phase_speed_from_steps(
    int steps
)
```

generate the speed from a number of steps 

**Parameters**: 

  * **steps** number of steps required in the trajectory 


**Return**: double the phase speed to obtain the desired number of steps in the trajectory 

## Friends

### friend operator<<

```cpp
friend std::ostream & operator<<(
    std::ostream & out,

    const ProMP & mp
);
```

Overloads << operator in order to print the weights of a given promp. 

**Parameters**: 

  * **out** The out 
  * **mp** THIS promp 


-------------------------------

Updated on 2022-01-20 at 11:06:17 +0100---
title: promp::Trajectory
summary: Class that represents a multidimensional trajectory. A trajectory is described by the values at each timestep and the speed parameter. speed indicates how the trajectory has been modulated, for example speed=2 means that the original trajectory had twice the timesteps. 

---

# promp::Trajectory



Class that represents a multidimensional trajectory. A trajectory is described by the values at each timestep and the speed parameter. speed indicates how the trajectory has been modulated, for example speed=2 means that the original trajectory had twice the timesteps. 


`#include <trajectory.hpp>`

## Public Functions

|                | Name           |
| -------------- | -------------- |
| | **[Trajectory](#function-trajectory)**() =default |
| | **[Trajectory](#function-trajectory)**(const Eigen::MatrixXd & data, double speed =1.0) |
| virtual | **[~Trajectory](#function-~trajectory)**() =default |
| size_t | **[dims](#function-dims)**() const |
| size_t | **[timesteps](#function-timesteps)**() const |
| double | **[speed](#function-speed)**() const |
| const Eigen::MatrixXd & | **[matrix](#function-matrix)**() const |
| [Trajectory]() | **[sub_trajectory](#function-sub-trajectory)**(size_t dim) const |
| [Trajectory]() | **[sub_trajectory](#function-sub-trajectory)**(const std::vector< size_t > & dims) const |
| void | **[modulate_in_place](#function-modulate-in-place)**(size_t timesteps, bool fast =true) |
| [Trajectory]() | **[modulate](#function-modulate)**(size_t steps, bool fast =true) const |
| double | **[distance](#function-distance)**(const [Trajectory]() & other, bool modulate =false) const |
| double | **[infer_speed](#function-infer-speed)**(const Eigen::MatrixXd & obs_traj, double lb, double ub, size_t steps) const |

## Public Functions Documentation

### function Trajectory

```cpp
Trajectory() =default
```


\brief default constructor. Build empty trajectory. 


### function Trajectory

```cpp
explicit Trajectory(
    const Eigen::MatrixXd & data,
    double speed =1.0
)
```


\brief constructor that build a trajectory starting from data and speed \param data Eigen::Matrix containing the raw data, each column is a different dof \param speed speed of the original trajectory (time-scale factor: e.g., 2.0 to go from 200 time-steps to 100 time-steps) 


### function ~Trajectory

```cpp
virtual ~Trajectory() =default
```


### function dims

```cpp
inline size_t dims() const
```


\brief return number of dimensions of the trajectory 


### function timesteps

```cpp
inline size_t timesteps() const
```


\brief return number of timesteps in the trajectory 


### function speed

```cpp
inline double speed() const
```


\brief return the trajectory' speed 


### function matrix

```cpp
inline const Eigen::MatrixXd & matrix() const
```


\brief return the raw data as Eigen::Matrix 


### function sub_trajectory

```cpp
Trajectory sub_trajectory(
    size_t dim
) const
```


\brief return monodimensional trajectory from the selected dimension \param dim dimension used to create the returned trajectory 


### function sub_trajectory

```cpp
Trajectory sub_trajectory(
    const std::vector< size_t > & dims
) const
```


\brief return trajectory using data from the selected dimensions \param dim list of dimensions used to create the returned trajectory 


### function modulate_in_place

```cpp
void modulate_in_place(
    size_t timesteps,
    bool fast =true
)
```


\brief modulate the trajectory to the desired number of timesteps Adjust speed according to speed = this->[speed()](#function-speed) * this->[timesteps()](#function-timesteps) / timesteps \param timesteps desired number of steps in the trajectory 


### function modulate

```cpp
Trajectory modulate(
    size_t steps,
    bool fast =true
) const
```


\brief create a new modulated trajectory with the desired number of timesteps Adjust its speed according to speed = this->[speed()](#function-speed) * this->[timesteps()](#function-timesteps) / timesteps \param timesteps desired number of steps in the trajectory 


### function distance

```cpp
double distance(
    const Trajectory & other,
    bool modulate =false
) const
```


\brief compute the Euclidean distance between this and a second trajectory \param other trajectory used to compute the distance with \param modulate if false the distance is computed using data until the smaller trajectory lenght, if true the other trajectory is modulated to this trajectory length before computing the distance 


### function infer_speed

```cpp
double infer_speed(
    const Eigen::MatrixXd & obs_traj,
    double lb,
    double ub,
    size_t steps
) const
```


\brief infer the speed of a trajectory starting from the raw data \param obs_traj data from whoch speed is inferred, comparing it to this trajectory \param lb lower bound for inferred speed \param ub upper bound for inferred speed \param steps number of speeds to be tested (linspace(lb, ub, steps)) 


-------------------------------

Updated on 2022-01-20 at 11:06:17 +0100---
title: promp::TrajectoryGroup
summary: Class for handling data from multiple trajectories. Data from each trajectory should be stored in an individual file, files can be generated from serializer or be in .csv format. Each column within .csv file represents a trajectory. All .csv files must have trajectories(columns) in the same sequence (column-wise) 

---

# promp::TrajectoryGroup



Class for handling data from multiple trajectories. Data from each trajectory should be stored in an individual file, files can be generated from serializer or be in .csv format. Each column within .csv file represents a trajectory. All .csv files must have trajectories(columns) in the same sequence (column-wise) 


`#include <trajectory_group.hpp>`

## Public Functions

|                | Name           |
| -------------- | -------------- |
| | **[TrajectoryGroup](#function-trajectorygroup)**() =default |
| void | **[load_trajectories](#function-load-trajectories)**(const std::vector< std::string > & files, const std::vector< size_t > & index) |
| void | **[load_csv_trajectories](#function-load-csv-trajectories)**(const std::vector< std::string > & files, const std::vector< size_t > & index, char sep =',', bool skip_header =false) |
| void | **[load_csv_trajectories](#function-load-csv-trajectories)**(const std::vector< std::string > & files, const std::vector< std::string > & cols, char sep =',') |
| size_t | **[normalize_length](#function-normalize-length)**() |
| void | **[normalize_length](#function-normalize-length)**(size_t len) |
| std::pair< Eigen::VectorXd, Eigen::VectorXd > | **[standardize_dims](#function-standardize-dims)**() |
| const std::vector< [Trajectory]() > & | **[trajectories](#function-trajectories)**() const |

## Public Functions Documentation

### function TrajectoryGroup

```cpp
TrajectoryGroup() =default
```


\brief default constructor: create an empty trajectory group 


### function load_trajectories

```cpp
void load_trajectories(
    const std::vector< std::string > & files,
    const std::vector< size_t > & index
)
```


\brief load trajectories from list of files (formatted as generated from io/serializer). \param files of files. \param index list of indexes representing dofs to keep. 


### function load_csv_trajectories

```cpp
void load_csv_trajectories(
    const std::vector< std::string > & files,
    const std::vector< size_t > & index,
    char sep =',',
    bool skip_header =false
)
```


\brief load trajectories from list of .csv files. \param files of files. \param index list of indexes representing dofs to keep. \param sep values separator. \param skip_header if true skip first line. 


### function load_csv_trajectories

```cpp
void load_csv_trajectories(
    const std::vector< std::string > & files,
    const std::vector< std::string > & cols,
    char sep =','
)
```


\brief load trajectories from list of .csv files. \param files of files. \param cols list of columns (dofs) to keep. \param sep values separator. 


### function normalize_length

```cpp
size_t normalize_length()
```


\brief Normalize all trajectories to the mean length (number of timesteps) 


### function normalize_length

```cpp
void normalize_length(
    size_t len
)
```


\brief Normalize all trajectories to the same desired length \param len desired length 


### function standardize_dims

```cpp
std::pair< Eigen::VectorXd, Eigen::VectorXd > standardize_dims()
```


\brief standardize each dof among the trajectories 


### function trajectories

```cpp
inline const std::vector< Trajectory > & trajectories() const
```


\brief return the vector of trajectories 


-------------------------------

Updated on 2022-01-20 at 11:06:17 +0100---
title: promp::io::CSVReader
summary: Class reading data from .csv files. 

---

# promp::io::CSVReader



Class reading data from .csv files. 


`#include <csv_reader.hpp>`

## Public Functions

|                | Name           |
| -------------- | -------------- |
| | **[CSVReader](#function-csvreader)**(const std::string & filename, char delm =',', bool skip_header =false) |
| Eigen::MatrixXd | **[get_data](#function-get-data)**() |
| Eigen::VectorXd | **[get_data_dof](#function-get-data-dof)**(const std::string & dof, const Eigen::MatrixXd & data) |
| Eigen::MatrixXd | **[get_data_dofs](#function-get-data-dofs)**(const std::vector< std::string > & dofs, const Eigen::MatrixXd & data) |
| Eigen::VectorXd | **[get_data_dof](#function-get-data-dof)**(size_t dof, const Eigen::MatrixXd & data) |
| Eigen::MatrixXd | **[get_data_dofs](#function-get-data-dofs)**(const std::vector< size_t > & dofs, const Eigen::MatrixXd & data) |

## Public Functions Documentation

### function CSVReader

```cpp
CSVReader(
    const std::string & filename,
    char delm =',',
    bool skip_header =false
)
```


### function get_data

```cpp
Eigen::MatrixXd get_data()
```


### function get_data_dof

```cpp
Eigen::VectorXd get_data_dof(
    const std::string & dof,
    const Eigen::MatrixXd & data
)
```


### function get_data_dofs

```cpp
Eigen::MatrixXd get_data_dofs(
    const std::vector< std::string > & dofs,
    const Eigen::MatrixXd & data
)
```


### function get_data_dof

```cpp
static Eigen::VectorXd get_data_dof(
    size_t dof,
    const Eigen::MatrixXd & data
)
```


### function get_data_dofs

```cpp
static Eigen::MatrixXd get_data_dofs(
    const std::vector< size_t > & dofs,
    const Eigen::MatrixXd & data
)
```


-------------------------------

Updated on 2022-01-20 at 11:06:17 +0100